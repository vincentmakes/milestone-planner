{"version":3,"file":"criticalPath-CabRwJM7.js","sources":["../../src/components/gantt/utils/criticalPath.ts"],"sourcesContent":["/**\n * Critical Path Method (CPM) Calculator\n * \n * Calculates the critical path for a project based on phases, subphases, and their dependencies.\n * The critical path is the longest path through the project network, determining the minimum\n * project duration. Items on the critical path have zero float/slack.\n */\n\nimport type { Project, Subphase, Dependency } from '@/types';\n\n// Represents a node in the project network\ninterface NetworkNode {\n  id: string;           // Unique identifier: 'phase-{id}' or 'subphase-{id}'\n  type: 'phase' | 'subphase';\n  entityId: number;     // Original phase/subphase ID\n  name: string;\n  startDate: Date;\n  endDate: Date;\n  duration: number;     // Duration in days\n  dependencies: Dependency[];\n  // CPM calculated values\n  earlyStart: number;   // Earliest start time\n  earlyFinish: number;  // Earliest finish time\n  lateStart: number;    // Latest start time\n  lateFinish: number;   // Latest finish time\n  totalFloat: number;   // Total float/slack\n}\n\n/**\n * Calculate the duration in days between two dates\n */\nfunction calculateDuration(startDate: string, endDate: string): number {\n  const start = new Date(startDate);\n  const end = new Date(endDate);\n  const diffTime = end.getTime() - start.getTime();\n  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n  return Math.max(1, diffDays + 1); // Include both start and end day, minimum 1 day\n}\n\n/**\n * Convert a date string to a day number (days since project start)\n */\nfunction dateToDayNumber(dateStr: string, projectStartDate: Date): number {\n  const date = new Date(dateStr);\n  const diffTime = date.getTime() - projectStartDate.getTime();\n  return Math.floor(diffTime / (1000 * 60 * 60 * 24));\n}\n\n/**\n * Build a flat list of all phases and subphases as network nodes\n */\nfunction buildNetworkNodes(project: Project, projectStartDate: Date): NetworkNode[] {\n  const nodes: NetworkNode[] = [];\n  \n  // Add all phases\n  for (const phase of project.phases ?? []) {\n    nodes.push({\n      id: `phase-${phase.id}`,\n      type: 'phase',\n      entityId: phase.id,\n      name: phase.name,\n      startDate: new Date(phase.start_date),\n      endDate: new Date(phase.end_date),\n      duration: calculateDuration(phase.start_date, phase.end_date),\n      dependencies: phase.dependencies ?? [],\n      earlyStart: dateToDayNumber(phase.start_date, projectStartDate),\n      earlyFinish: 0,\n      lateStart: 0,\n      lateFinish: 0,\n      totalFloat: 0,\n    });\n    \n    // Recursively add subphases\n    const addSubphases = (subphases: Subphase[]) => {\n      for (const subphase of subphases) {\n        nodes.push({\n          id: `subphase-${subphase.id}`,\n          type: 'subphase',\n          entityId: subphase.id,\n          name: subphase.name,\n          startDate: new Date(subphase.start_date),\n          endDate: new Date(subphase.end_date),\n          duration: calculateDuration(subphase.start_date, subphase.end_date),\n          dependencies: subphase.dependencies ?? [],\n          earlyStart: dateToDayNumber(subphase.start_date, projectStartDate),\n          earlyFinish: 0,\n          lateStart: 0,\n          lateFinish: 0,\n          totalFloat: 0,\n        });\n        \n        if (subphase.children?.length) {\n          addSubphases(subphase.children);\n        }\n      }\n    };\n    \n    if (phase.children?.length) {\n      addSubphases(phase.children);\n    }\n  }\n  \n  return nodes;\n}\n\n/**\n * Perform forward pass to calculate early start and early finish times\n */\nfunction forwardPass(nodes: NetworkNode[], nodeMap: Map<string, NetworkNode>): void {\n  // Sort nodes by early start (which is initially based on actual start dates)\n  const sortedNodes = [...nodes].sort((a, b) => a.earlyStart - b.earlyStart);\n  \n  for (const node of sortedNodes) {\n    // Calculate early finish\n    node.earlyFinish = node.earlyStart + node.duration - 1;\n    \n    // For nodes with dependencies, early start must be after all predecessors finish\n    for (const dep of node.dependencies) {\n      const predecessorId = `phase-${dep.id}`;\n      const predecessorIdSub = `subphase-${dep.id}`;\n      const predNode = nodeMap.get(predecessorId) || nodeMap.get(predecessorIdSub);\n      \n      if (predNode) {\n        let requiredStart: number;\n        const lag = dep.lag ?? 0;\n        \n        switch (dep.type) {\n          case 'FS': // Finish-to-Start\n            requiredStart = predNode.earlyFinish + 1 + lag;\n            break;\n          case 'SS': // Start-to-Start\n            requiredStart = predNode.earlyStart + lag;\n            break;\n          case 'FF': // Finish-to-Finish\n            requiredStart = predNode.earlyFinish - node.duration + 1 + lag;\n            break;\n          case 'SF': // Start-to-Finish\n            requiredStart = predNode.earlyStart - node.duration + 1 + lag;\n            break;\n          default:\n            requiredStart = predNode.earlyFinish + 1 + lag;\n        }\n        \n        if (requiredStart > node.earlyStart) {\n          node.earlyStart = requiredStart;\n          node.earlyFinish = node.earlyStart + node.duration - 1;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Perform backward pass to calculate late start and late finish times\n */\nfunction backwardPass(nodes: NetworkNode[], nodeMap: Map<string, NetworkNode>, projectEndDay: number): void {\n  // Initialize late finish for all nodes to project end\n  for (const node of nodes) {\n    node.lateFinish = projectEndDay;\n    node.lateStart = node.lateFinish - node.duration + 1;\n  }\n  \n  // Sort nodes by early finish in descending order\n  const sortedNodes = [...nodes].sort((a, b) => b.earlyFinish - a.earlyFinish);\n  \n  // Build reverse dependency map (successor -> predecessors)\n  const reverseDeps = new Map<string, Array<{ node: NetworkNode; dep: Dependency }>>();\n  for (const node of nodes) {\n    for (const dep of node.dependencies) {\n      const predecessorId = `phase-${dep.id}`;\n      const predecessorIdSub = `subphase-${dep.id}`;\n      const predNode = nodeMap.get(predecessorId) || nodeMap.get(predecessorIdSub);\n      \n      if (predNode) {\n        if (!reverseDeps.has(predNode.id)) {\n          reverseDeps.set(predNode.id, []);\n        }\n        reverseDeps.get(predNode.id)!.push({ node, dep });\n      }\n    }\n  }\n  \n  for (const node of sortedNodes) {\n    // Find all successors and adjust late finish\n    const successors = reverseDeps.get(node.id) || [];\n    \n    for (const { node: succNode, dep } of successors) {\n      let requiredFinish: number;\n      const lag = dep.lag ?? 0;\n      \n      switch (dep.type) {\n        case 'FS': // Finish-to-Start\n          requiredFinish = succNode.lateStart - 1 - lag;\n          break;\n        case 'SS': // Start-to-Start\n          requiredFinish = succNode.lateStart + node.duration - 1 - lag;\n          break;\n        case 'FF': // Finish-to-Finish\n          requiredFinish = succNode.lateFinish - lag;\n          break;\n        case 'SF': // Start-to-Finish\n          requiredFinish = succNode.lateFinish + node.duration - 1 - lag;\n          break;\n        default:\n          requiredFinish = succNode.lateStart - 1 - lag;\n      }\n      \n      if (requiredFinish < node.lateFinish) {\n        node.lateFinish = requiredFinish;\n        node.lateStart = node.lateFinish - node.duration + 1;\n      }\n    }\n  }\n}\n\n/**\n * Calculate total float for each node\n * Float = Late Start - Early Start (or Late Finish - Early Finish)\n */\nfunction calculateFloat(nodes: NetworkNode[]): void {\n  for (const node of nodes) {\n    node.totalFloat = node.lateStart - node.earlyStart;\n  }\n}\n\n/**\n * Identify critical path items (those with zero or near-zero float)\n */\nfunction identifyCriticalPath(nodes: NetworkNode[]): Set<string> {\n  const criticalItems = new Set<string>();\n  \n  // Items with float <= 0 are on the critical path\n  // We use <= 0 to account for any rounding issues\n  for (const node of nodes) {\n    if (node.totalFloat <= 0) {\n      criticalItems.add(node.id);\n    }\n  }\n  \n  return criticalItems;\n}\n\n/**\n * Main function to calculate critical path for a project\n * Returns a set of item IDs that are on the critical path\n * Format: 'phase-{id}' or 'subphase-{id}'\n */\nexport function calculateCriticalPath(project: Project): CriticalPathResult {\n  const phases = project.phases ?? [];\n  \n  // If no phases or no dependencies, return empty result\n  if (phases.length === 0) {\n    return { criticalItems: new Set(), hasDependencies: false };\n  }\n  \n  // Check if there are any dependencies\n  let hasDependencies = false;\n  for (const phase of phases) {\n    if (phase.dependencies?.length > 0) {\n      hasDependencies = true;\n      break;\n    }\n    const checkSubphaseDeps = (subphases: Subphase[]): boolean => {\n      for (const sp of subphases) {\n        if (sp.dependencies?.length > 0) return true;\n        if (sp.children?.length && checkSubphaseDeps(sp.children)) return true;\n      }\n      return false;\n    };\n    if (phase.children?.length && checkSubphaseDeps(phase.children)) {\n      hasDependencies = true;\n      break;\n    }\n  }\n  \n  // Find project start and end dates\n  let projectStartDate: Date | null = null;\n  let projectEndDate: Date | null = null;\n  \n  for (const phase of phases) {\n    const phaseStart = new Date(phase.start_date);\n    const phaseEnd = new Date(phase.end_date);\n    \n    if (!projectStartDate || phaseStart < projectStartDate) {\n      projectStartDate = phaseStart;\n    }\n    if (!projectEndDate || phaseEnd > projectEndDate) {\n      projectEndDate = phaseEnd;\n    }\n  }\n  \n  if (!projectStartDate || !projectEndDate) {\n    return { criticalItems: new Set(), hasDependencies };\n  }\n  \n  // Build network nodes\n  const nodes = buildNetworkNodes(project, projectStartDate);\n  \n  if (nodes.length === 0) {\n    return { criticalItems: new Set(), hasDependencies };\n  }\n  \n  // Create a map for quick node lookup\n  const nodeMap = new Map<string, NetworkNode>();\n  for (const node of nodes) {\n    nodeMap.set(node.id, node);\n  }\n  \n  // Calculate project end day number\n  const projectEndDay = Math.ceil((projectEndDate.getTime() - projectStartDate.getTime()) / (1000 * 60 * 60 * 24));\n  \n  // Perform CPM calculations\n  forwardPass(nodes, nodeMap);\n  backwardPass(nodes, nodeMap, projectEndDay);\n  calculateFloat(nodes);\n  \n  // Identify critical path\n  const criticalItems = identifyCriticalPath(nodes);\n  \n  return { criticalItems, hasDependencies };\n}\n\nexport interface CriticalPathResult {\n  criticalItems: Set<string>;  // Set of 'phase-{id}' or 'subphase-{id}'\n  hasDependencies: boolean;    // Whether the project has any dependencies\n}\n\n/**\n * Check if a specific phase is on the critical path\n */\nexport function isPhaseOnCriticalPath(phaseId: number, criticalItems: Set<string>): boolean {\n  return criticalItems.has(`phase-${phaseId}`);\n}\n\n/**\n * Check if a specific subphase is on the critical path\n */\nexport function isSubphaseOnCriticalPath(subphaseId: number, criticalItems: Set<string>): boolean {\n  return criticalItems.has(`subphase-${subphaseId}`);\n}\n"],"names":["calculateDuration","startDate","endDate","start","diffTime","diffDays","dateToDayNumber","dateStr","projectStartDate","buildNetworkNodes","project","nodes","phase","addSubphases","subphases","subphase","forwardPass","nodeMap","sortedNodes","a","b","node","dep","predecessorId","predecessorIdSub","predNode","requiredStart","lag","backwardPass","projectEndDay","reverseDeps","successors","succNode","requiredFinish","calculateFloat","identifyCriticalPath","criticalItems","calculateCriticalPath","phases","hasDependencies","checkSubphaseDeps","sp","projectEndDate","phaseStart","phaseEnd"],"mappings":"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"}